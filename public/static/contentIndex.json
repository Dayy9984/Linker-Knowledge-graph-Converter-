{"CORS":{"title":"CORS","links":[],"tags":[],"content":"CORS는 무엇인가요? §\n브라우저에서는 보안적인 이유로 cross-origin HTTP 요청들을 제한합니다. 그래서 cross-origin 요청을 하려면 서버의 동의가 필요합니다. 만약 서버가 동의한다면 브라우저에서는 요청을 허락하고, 동의하지 않는다면 브라우저에서 거절합니다.\n이러한 허락을 구하고 거절하는 메커니즘을 HTTP-header를 이용해서 가능한데, 이를 CORS(Cross-Origin Resource Sharing)라고 부릅니다.\n그래서 브라우저에서 cross-origin 요청을 안전하게 할 수 있도록 하는 메커니즘입니다.\ncross-origin §\ncross-origin이란 다음 중 한 가지라도 다른 경우를 말합니다.\n\n프로토콜 - http와 https는 프로토콜이 다르다.\n도메인 - domain.com과 other-domain.com은 다르다.\n포트 번호 - 8080포트와 3000포트는 다르다.\n\nCORS는 왜 필요한가요? §\nCORS가 없이 모든 곳에서 데이터를 요청할 수 있게 되면, 다른 사이트에서 원래 사이트를 흉내낼 수 있게 됩니다. 예를 들어서 기존 사이트와 완전히 동일하게 동작하도록 하여 사용자가 로그인을 하도록 만들고, 로그인했던 세션을 탈취하여 악의적으로 정보를 추출하거나 다른 사람의 정보를 입력하는 등 공격을 할 수 있습니다. 이렇나 공격을 할 수 없도록 브라우저에서 보호하고, 필요한 경우 에만 서버와 협의하여 요청할 수 있도록 하기 위해서 필요합니다.\nCORS는 어떻게 동작하나요? §\nSimple requests인 경우 §\n\n서버로 요청을 합니다.\n서버의 응답이 왔을 때 브라우저가 요청한 Origin과 응답한 헤더 Access-Control-Request-Headers의 값을 비교하여 유효한 요청이라면 리소스를 응답합니다. 만약 유효하지 않은 요청이라면 브라우저에서 이를 막고 에러가 발생합니다.\n\nSimple requests란? §\nHTTP method가 다음 중 하나이면서\n\nGET\nHEAD\nPOST\n\n자동으로 설정되는 헤더는 제외하고, 설정할 수 있는 다음 헤더들만 변경하면서\n\nAccept\nAccept-Language\nContent-Language\n\nContent-Type이 다음과 같은 경우\n\napplication/x-www-form-urlencoded\nmultipart/form-data\ntext/plain\n\nSimple requqets라고 부릅니다. 이 요청은 추가적으로 확인하지 않고 바로 본 요청을 보냅니다.\npreflight 요청일 경우 §\n\nOrigin헤더에 현재 요청하는 origin과, Access-Control-Request-Method헤더에 요청하는 HTTP method와 Access-Control-Request-Headers요청 시 사용할 헤더를 OPTIONS 메서드로 서버로 요청합니다. 이때 내용물은 없이 헤더만 전송합니다.\n브라우저가 서버에서 응답한 헤더를 보고 유효한 요청인지 확인합니다. 만약 유효하지 않은 요청이라면 요청은 중단되고 에러가 발생합니다. 만약 유효한 요청이라면 원래 요청으로 보내려던 요청을 다시 요청하여 리소스를 응답받습니다.\n\npreflight 요청이란? §\nSimple requests가 아닌 cross-origin요청은 모두 preflight 요청을 하게 되는데, 실제 요청을 보내는 것이 안전한지 확인하기 위해 먼저 OPTIONS 메서드를 사용하여 cross-origin HTTP 요청을 보냅니다. 이렇게 하는 이유는 사용자 데이터에 영향을 미칠 수 있는 요청이므로 사전에 확인 후 본 요청을 보냅니다.\n요청 헤더 목록 §\n\nOrigin\nAccess-Control-Request-Method\n\npreflight 요청을 할 때 실제 요청에서 어떤 메서드를 사용할 것인지 서버에게 알리기 위해 사용됩니다.\n\n\nAccess-Control-Request-Headers\n\npreflight요청을 할 때 실제 요청에서 어떤 header를 사용할 것인지 서버에게 알리기 위해 사용됩니다.\n\n\n\n응답 헤더 목록 §\n\nAccess-Control-Allow-Origin\n\n브라우저가 해당 origin이 자원에 접근할 수 있도록 허용합니다. 혹은 *은 credentials이 없는 요청에 한해서 모든 origin에서 접근이 가능하도록 허용합니다.\n\n\nAccess-Control-Expose-Headers\n\n브라우저가 액세스할 수 있는 서버 화이트리스트 헤더를 허용합니다.\n\n\nAccess-Control-Max-Age\n\n얼마나 오랫동안 preflight요청이 캐싱 될 수 있는지를 나타낸다.\n\n\nAccess-Control-Allow-Credentials\n\nCredentials가 true 일 때 요청에 대한 응답이 노출될 수 있는지를 나타냅니다.\npreflight요청에 대한 응답의 일부로 사용되는 경우 실제 자격 증명을 사용하여 실제 요청을 수행할 수 있는지를 나타냅니다.\n간단한 GET 요청은 preflight되지 않으므로 자격 증명이 있는 리소스를 요청하면 헤더가 리소스와 함께 반환되지 않으면 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않습니다.\n\n\nAccess-Control-Allow-Methods\n\npreflight`요청에 대한 대한 응답으로 허용되는 메서드들을 나타냅니다.\n\n\nAccess-Control-Allow-Headers\n\npreflight요청에 대한 대한 응답으로 실제 요청 시 사용할 수 있는 HTTP 헤더를 나타냅니다.\n\n\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/DHCP-in-the-Network":{"title":"DHCP in the Network","links":[],"tags":[],"content":"\n\nDHCP automates the assignment of IP addresses and network configuration details to devices on a network.\n\n\nDynamic IP addressing via DHCP is scalable and less error-prone than static IP addressing, especially as a network grows.\n\n\nDHCP Process:\n\nA client sends a discovery packet upon boot-up to acquire an IP configuration.\nDHCP servers listen on port 67 and respond with an offer packet.\nClients reply with a request packet, and the DHCP server sends back an acknowledgment with the necessary IP configuration.\n\n\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Instructor":{"title":"Instructor","links":[],"tags":[],"content":"Brian Farrell §\nBrian Farrell is the instructor from Edmonds College responsible for developing this network engineering course."},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Layer-One-Devices":{"title":"Layer One Devices","links":[],"tags":[],"content":"\nModems modulate and demodulate analog signals for network connections over telephone lines.\nHubs replicate incoming network signals to all ports, acting as signal repeaters.\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Layer-Three-Devices":{"title":"Layer Three Devices","links":[],"tags":[],"content":"\nMulti-layer switches provide both switching and routing functions, facilitating data transfer between different network devices.\nRouters connect diverse networks and manage the best routes for data packets based on layer three network information.\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Layer-Two-Devices":{"title":"Layer Two Devices","links":[],"tags":[],"content":"\nSwitches learn attached devices’ locations via MAC addresses and facilitate communication between local network devices.\nWireless access points connect wireless network segments to wired ones.\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Network-Engineering-Course":{"title":"Network Engineering Course","links":[],"tags":[],"content":"Introduction to Network Engineering §\nThis course discusses configuring, managing, and troubleshooting computer networks, and helps prepare for CompTIA’s Network+ exam."},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/OSI-Model":{"title":"OSI Model","links":[],"tags":[],"content":"\nA framework used to understand how different network protocols interact and function across seven defined layers.\nLayer one is dedicated to the physical connections in a network.\nLayer two deals with data framing and MAC addressing.\nLayer three concerns the network layer, routing, and IP addressing.\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Optimization-and-Performance-Devices":{"title":"Optimization and Performance Devices","links":[],"tags":[],"content":"\nLoad balancers ensure no single server in a server farm is overwhelmed by evenly distributing requests.\nProxy servers serve as intermediaries for clients to access external resources, also providing cache functions for improved network performance.\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/Security-Devices":{"title":"Security Devices","links":[],"tags":[],"content":"\nFirewalls secure networks by enforcing rules and managing packet traffic across different OSI layers.\nIntrusion Detection Systems (IDS) detect and alert network administrators of security breaches.\nIntrusion Prevention Systems (IPS) actively prevent and mitigate the effects of network attacks.\n"},"Computer-Networking-Course---Network-Engineering-[CompTIA-Network+-Exam-Prep]---영어/VPN-Concentrator":{"title":"VPN Concentrator","links":[],"tags":[],"content":"\nA device that manages the security and data tunneling for multiple VPN connections, typically functioning at layers two and three, and sometimes at layer seven for SSL VPNs.\n"},"E-R-모델":{"title":"E-R 모델","links":["데이터-요구사항","개념-스키마-설계","논리-스키마-설계","내부-스키마-설계"],"tags":[],"content":"E-R 모델과 릴레이션 변환 규칙을 이용한 설계는 아래 단계를 거쳐 데이터베이스를 생성.\n\n데이터 요구사항에 대한 분석 (결과 : 요구사항 명세서)\n개념 스키마 설계 (결과 : ERD)\n논리 스키마 설계 (결과 : 릴레이션 스키마의 테이블 명세서)\n내부 스키마 설계 (결과 : DB 스키마 생성 SQL 문)\n"},"HTTP문서/CDN":{"title":"CDN","links":[],"tags":[],"content":"\nCDN(Content Delivery Network)은 전세계에 분산된 서버 네트워크를 통해 콘텐츠를 효율적으로 제공합니다.\n캐싱은 CDN의 주요 기능 중 하나입니다.\n"},"HTTP문서/Cache-Control-헤더":{"title":"Cache-Control 헤더","links":[],"tags":[],"content":"\nCache-Control 헤더는 캐싱 동작을 제어하는데 사용되는 HTTP/1.1 헤더 필드입니다.\n캐싱 정책을 정의할 때 사용되며, 다양한 디렉티브를 제공합니다.\n"},"HTTP문서/ETag":{"title":"ETag","links":[],"tags":[],"content":"\nETag 헤더는 캐시된 문서의 검증을 위해 사용되는 강한 검증자입니다.\n최신 상태를 확인하고 클라이언트가 효율적으로 캐시를 활용할 수 있도록 도와줍니다.\n"},"HTTP문서/HTTP-캐싱":{"title":"HTTP 캐싱","links":["HTTP문서/웹-서버","HTTP문서/CDN","HTTP문서/리버스-프록시-캐시","HTTP문서/로드-밸런서"],"tags":[],"content":"HTTP 캐싱 §\nHTTP 캐싱은 웹 사이트와 애플리케이션의 성능 향상에 중요한 역할을 합니다. 리소스를 재활용함으로써 레이턴시와 네트워크 트래픽 감소에 도움이 되며, 결과적으로 웹 사이트의 반응 속도를 빠르게합니다.\n캐싱의 목표 §\n캐싱은 서버 부하 감소와 클라이언트에게 더 가까운 위치에서 빠르게 리소스를 제공합니다. 이로 인해 웹 사이트의 성능은 신뢰성, 확장성, 그리고 성능 향상을 제공하는 웹 서버, CDN, 리버스 프록시 캐시, 그리고 로드 밸런서와 같은 다양한 캐싱 시스템을 통해 최적화됩니다.\n사설과 공유 캐시 §\n사설 캐시는 단일 사용자만이 사용하는 반면 공유 캐시는 여러 사용자가 재활용할 수 있는 응답을 저장합니다. 이러한 이해는 캐시 유형을 선택하고 적용할 때 중요한 기준이 됩니다.\n캐싱 동작의 대상 §\nGET 요청에 대한 응답만 주로 캐싱되며, 캐시 키는 요청 메서드와 대상 URI로 이루어집니다.\n캐싱 제어 §\nCache-Control 헤더는 캐싱 메커니즘의 구체적인 행동을 지정합니다. 이는 no-store, no-cache, must-revalidate 등 다양한 디렉티브를 지니고 있습니다.\n유효성 및 만료 §\n리소스의 만료 시간이 지나면 캐시에서 제거되거나 리소스에 대한 재검증이 수행되어야 합니다. 이는 Cache-Control의 max-age 값이나 Expires 헤더를 통해 정의됩니다.\n리비전된 리소스 §\n파일의 이름에 버전 번호를 포함하여 리소스의 새로운 개정본을 만들어 충돌을 방지하는 것을 의미합니다. 이를 통해 캐시된 리소스들의 성능 최적화를 달성할 수 있습니다.\n캐시 검증 §\n캐시된 문서의 만료 시간이 다가올 때 캐시 검증이 진행됩니다. ETag와 Last-Modified 헤더를 통해 강한 검증 혹은 약한 검증을 할 수 있습니다.\nVary 헤더 §\nVary 헤더는 캐시가 특정 헤더를 기준으로 캐시된 응답을 사용할 수 있는지를 결정하는데 사용됩니다.\n정규화 §\n캐시 서버의 중복된 엔트리와 불필요한 요청을 줄이기 위하여 정규화를 수행할 수 있습니다. 이는 Accept-Encoding과 같은 헤더 값의 변형을 통해 이루어집니다."},"HTTP문서/Last-Modified":{"title":"Last-Modified","links":[],"tags":[],"content":"\nLast-Modified 헤더는 약한 검증을 사용하여 캐시된 문서의 수정 시각을 나타냅니다.\n클라이언트가 캐시된 문서의 상태를 확인할 때 사용됩니다.\n"},"HTTP문서/Vary-헤더":{"title":"Vary 헤더","links":[],"tags":[],"content":"\nVary 헤더는 캐시된 응답이 특정 조건에 따라 사용될 수 있는지를 결정하는 데 도움을 줍니다.\n컨텐츠 협상 및 적응형 캐싱에 유용합니다.\n"},"HTTP문서/로드-밸런서":{"title":"로드 밸런서","links":[],"tags":[],"content":"\n로드 밸런서는 네트워크 트래픽을 여러 서버로 분산시키는 기능을 합니다.\n높은 가용성과 분산 처리를 통해 캐싱과 함께 웹 서비스의 성능을 높입니다.\n"},"HTTP문서/리버스-프록시-캐시":{"title":"리버스 프록시 캐시","links":[],"tags":[],"content":"\n리버스 프록시 캐시는 클라이언트 요청을 받아 캐시된 응답을 제공하거나 원 서버로 전달합니다.\n캐싱을 통해 원본 서버의 부하를 줄이고 응답 시간을 단축합니다.\n"},"HTTP문서/웹-서버":{"title":"웹 서버","links":[],"tags":[],"content":"\n웹 서버는 요청을 처리하고 클라이언트에게 응답을 제공하는 소프트웨어입니다.\n캐싱 시스템을 통해 웹 서버는 성능을 향상시키고 스케일링을 지원합니다.\n"},"JWT":{"title":"JWT","links":[],"tags":[],"content":"정의.\n\nJSON 객체를 사용해서 토큰 자체에 정보들을 저장하고 있는 Web Token\n\n구성.\n\nHeader, Payload, Signature 3개의 부분으로 구성되어져 있음.\n\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c\n=&gt;\nHEADER:\n{\n“alg”: “HS256”,\n“typ”: “JWT”\n}\nPAYLOAD:\n{\n“sub”: “1234567890”,\n“name”: “John Doe”,\n“iat”: 1516239022\n}\nVERIFY SIGNATURE:\nHMACSHA256(\nbase64UrlEncode(header) + ”.” +\nbase64UrlEncode(payload),\n) secret base64 encoded\nHeader.\n\nSignature를 해싱하기 위한 알고리즘 정보들이 담겨있음.\n\nPayload.\n\n서버와 클라이언트가 주고받는, 시스템에서 실제로 사용될 정보에 대한 내용들을 담고있다.\n\nSignature.\n\n토큰의 유효성 검증을 위한 문자열. 이 문자열을 통해 서버에서 이 토큰이 유효한 토큰인지를 검증할 수 있다.\n\nJWT 장점.\n\n중앙의 인증 서버, 데이터 스토어에 대한 의존성 없음, 시스템 수평 확장 유리\nBase64 URL Safe Encoding &gt; URL, Cookie, Header 모두 사용 가능\n\nJWT 단점.\n\nPayload의 정보가 많아지면 네트워크 사용량 증가, 데이터 설계 고려 필요\n토큰이 클라이언트에 저장, 서버에서 클라이언트의 토큰을 조작할 수 없음.\n"},"index":{"title":"Welcome to Linker!","links":[],"tags":[],"content":"우리의 목표는 더 많은 사람들이 자신이 배운 내용을 잊지 않고 오래 간직하도록 돕는 것입니다.\n최근 이슈가 되고 있는 제텔카스텐 연상 기법은 그동안 배운 내용을 지식 그래프로 구현하여 기존 학습방식보다 더 빠르게 복습하고, 창의성을 자극하는 장점이 존재합니다.\n사람들이 지식그래프를 더 빠르고 쉽게 구현할 수 있도록 AI 기반 지식그래프 작성 프로그램을 제작하게 되었습니다."},"관계형-데이터-베이스":{"title":"관계형 데이터 베이스","links":["E-R-모델","릴레이션-변환-규칙","정규화","이상-현상"],"tags":[],"content":"관계형 데이터베이스를 설계하는 방법에는 주로 2가지 방법을 사용. \n\nE-R 모델과 릴레이션 변환 규칙을 이용한 설계\n정규화를 이용한 설계\n\n이상 현상(ex. 삽입, 삭제, 수정시 발생하는 문제)을 제거하면서 중복을 최소화하고 더 좋은 ‘작은’ 릴레이션으로 분해하는 작업이다.\n\n\n"},"데이터-요구사항":{"title":"데이터 요구사항","links":[],"tags":[],"content":"데이터베이스에 대한 사용자의 요구사항을 수집하고 분석해서 아래와 같이 요구사항 명세서를 작성해야 한다. 아래는 예제\n\n\n한빛 항공사에 회원으로 가입하려면 회원아이디, 비밀번호, 성명, 신용카드 정보를 입력해야 한다\n\n\n회원의 신용카드 정보는 여러 개를 저장할 수 있는데, 세부적으로는 신용카드번호, 유효기간을 저장할 수 있다\n\n\n한빛 항공사에서는 보유한 비행기에 대해 비행기번호, 출발날짜, 출발시간 정보를 저장하고 있다\n\n\n한빛 항공사에서는 좌석에 대한 좌석번호, 등급 정보를 저장하고 있다\n\n\n회원은 좌석을 예약하는데, 회원 한 명은 좌석을 하나만 예약할 수 있고, 한 좌석은 회원 한명만 예약할 수 있다\n\n\n비행기에는 좌석이 존재하는데, 비행기 하나에는 좌석이 여러 개 존재할 수 있고 한 좌석은 반드시 하나의 비행기에만 존재해야 한다. \n그리고 좌석은 비행기가 없으면 의미가 없다.\n\n\n우리 프로젝트에서 데이터 요구사항은 노션에 정리함\nhttps://www.notion.so/e5bb0b07335a4accbb80e05df6d82da4?pvs=4\n"},"로그인-기능":{"title":"로그인 기능","links":["쿠키","세션","JWT"],"tags":[],"content":"로그인 기능을 구현하는 방법에는 쿠키 , 세션 , JWT 가 있다."},"세션":{"title":"세션","links":["세션-클러스터링","L4","로드밸런싱","CORS","JWT"],"tags":[],"content":"\nClient -&gt;로그인 서비스 요청 -&gt; Server\nClient -&gt;로그인 서비스 요청 -&gt; Server 세션 생성/ 유지\nClient &lt;- 로그인 응답 &lt;- Server\n\n\n\n이때 서버가 여러대를 사용하는 경우 세션 클러스터링을 통해 세션의 정보가 동기화가 되어야 한다\n\n\n클라이언트에서 요청하는 서버를 L4를 통해 로드밸런싱을 해준다.\n\n\n세션은 Stateful 한 서비스 지속적으로 연결되어있\n문제점1. 복잡하다.  그리고 요청이 올때마다 서버에서 세션을 읽고 DB접근을 하므로 트래픽이 많은 서비스에는 서버에 부하를 줄 수 있다.\n-&gt; 간단한 서비스에 사용\n문제점2. CORS 문제가 발생할 수 있음\n\n\n=&gt; 이런 문제들을 해결할 수 있는게 JWT"},"유저":{"title":"유저","links":[],"tags":[],"content":"\n유저 정보를 Spring Security를 통해 만드는 경우 User Class를 [App이름]User와 같이 작성해야 어플리케이션 간 문제가 생기지 않는다.\n"}}